<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.18.0/plotly.min.js"></script>
    <title>Hypersonic Glide Vehicle Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            margin-bottom: 20px;
        }

        /* Typography */
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        h2 {
            color: #34495e;
            margin-bottom: 20px;
            font-size: 1.8rem;
            font-weight: 600;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }

        h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-weight: 600;
        }

        /* Input section styling */
        .input-section {
            background: rgba(255, 255, 255, 0.8);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .parameter-group {
            margin-bottom: 25px;
            padding: 20px;
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            border-radius: 12px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .parameter-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.15);
        }

        .input-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            gap: 15px;
        }

        .input-row:last-child {
            margin-bottom: 0;
        }

        label {
            flex: 1;
            font-weight: 500;
            color: #2c3e50;
            min-width: 200px;
        }

        input[type="number"] {
            flex: 0 0 120px;
            padding: 10px 15px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: scale(1.02);
        }

        input[type="number"]:hover {
            border-color: #764ba2;
        }

        /* Button styling */
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #laminarBtn {
            background: linear-gradient(45deg, #4facfe, #00f2fe);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        #turbulentBtn {
            background: linear-gradient(45deg, #f55b2c, #e92626);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        #footprintBtn {
            background: linear-gradient(45deg, #f093fb, #f5576c);
            color: white;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        #resetBtn {
            background: linear-gradient(45deg, #b2fe4f, #26fe00);
            color: white;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        #exportBtn {
            background: linear-gradient(45deg, #43e97b, #38f9d7);
            color: white;
            box-shadow: 0 4px 15px rgba(67, 233, 123, 0.4);
            margin-bottom: 20px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(-1px);
        }

        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        button:hover::before {
            left: 100%;
        }

        /* Loading indicator */
        #loading {
            text-align: center;
            padding: 40px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            margin: 20px 0;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        #loading p {
            font-size: 18px;
            font-weight: 500;
            color: #667eea;
        }

        /* Results section */
        #results-section, #footprint-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        /* Statistics styling */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-item {
            background: linear-gradient(145deg, #f8f9fa, #e9ecef);
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s ease;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .stat-item strong {
            color: #2c3e50;
            display: block;
            margin-bottom: 5px;
        }

        /* Plot containers - SIMPLIFIED FOR PLOTLY COMPATIBILITY */
        #plots-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .plot-container {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.1);
        }

        .plot-container h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #2c3e50;
            font-size: 1.2rem;
        }

        /* Data table styling */
        #data-table-section {
            margin-top: 30px;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
        }

        #data-table-container {
            overflow-x: auto;
            margin-top: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 14px;
        }

        #data-table th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 12px 8px;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        #data-table td {
            padding: 10px 8px;
            text-align: center;
            border-bottom: 1px solid #e1e8ed;
        }

        #data-table tbody tr:nth-child(even) {
            background-color: #f8f9fa;
        }

        #data-table tbody tr:hover {
            background-color: rgba(102, 126, 234, 0.1);
            transform: scale(1.01);
            transition: all 0.2s ease;
        }

        /* Error section */
        #error-section {
            background: linear-gradient(145deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.3);
        }

        #error-message {
            font-weight: 500;
            text-align: center;
        }

        /* Footprint image styling */
        #plot-footprint {
            max-width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            display: block;
            margin: 0 auto;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .input-row {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            label {
                min-width: auto;
            }
            
            input[type="number"] {
                flex: 1;
            }
            
            .button-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            button {
                width: 100%;
                margin-bottom: 10px;
            }
            
            #plots-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .plot-container {
                min-width: auto;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .container {
                margin: 5px;
                padding: 10px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .input-section, #results-section, #footprint-section {
                padding: 20px;
            }
            
            .parameter-group {
                padding: 15px;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #764ba2, #667eea);
        }
        /* Map section styling */
        #map-section {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            margin-top: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        #map-container {
            width: 100%;
            height: 600px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .map-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 500;
            color: #2c3e50;
            font-size: 14px;
        }

        .control-group input {
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 14px;
            width: 120px;
        }

        #projectFootprintBtn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #projectFootprintBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.6);
        }

        .direction-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            font-weight: 500;
            color: #2c3e50;
            z-index: 1000;
        }

        /* Footprint legend */
        .footprint-legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 3px;
            border-radius: 2px;
        }

        /* Loading overlay for map */
        .map-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            border-radius: 12px;
        }

        .map-loading p {
            font-size: 16px;
            font-weight: 500;
            color: #667eea;
        }

        .advanced-settings-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .advanced-settings-btn:hover {
            background: #e9ecef;
        }

        .advanced-settings-panel {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                max-height: 0;
            }
            to {
                opacity: 1;
                max-height: 500px;
            }
        }

        .roll-changes-info {
            margin-bottom: 15px;
            color: #666;
            font-size: 14px;
        }

        .roll-change-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
        }

        .roll-change-item label {
            font-weight: 500;
            min-width: 80px;
        }

        .roll-change-item input {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            font-size: 14px;
        }

        .remove-roll-change-btn {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.2s ease;
        }

        .remove-roll-change-btn:hover {
            background: #c82333;
        }

        .add-roll-change-btn {
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        .add-roll-change-btn:hover {
            background: #218838;
        }

        .trajectory-map-info {
            margin-bottom: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            border-radius: 4px;
            font-size: 14px;
        }

        .trajectory-map-controls {
            display: flex;
            gap: 15px;
            align-items: end;
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            flex-wrap: wrap;
        }

        .trajectory-map-controls .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .trajectory-map-controls label {
            font-weight: 500;
            font-size: 14px;
        }

        .trajectory-map-controls input {
            padding: 6px 10px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            width: 120px;
        }

        #projectTrajectoryBtn {
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s ease;
        }

        #projectTrajectoryBtn:hover {
            background: #0056b3;
        }

        #trajectory-map-container {
            position: relative;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            overflow: hidden;
        }

        #trajectory-map {
            width: 100%;
            height: 500px;
        }

        .trajectory-direction-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .trajectory-legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .trajectory-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .trajectory-legend .legend-item:last-child {
            margin-bottom: 0;
        }

        .trajectory-legend .legend-color {
            display: inline-block;
        }

        .map-loading {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hypersonic Glide Vehicle Simulator</h1>
        
        <!-- Input Parameters Form -->
        <div class="input-section">
            <h2>Vehicle Parameters</h2>
            <form id="simulationForm">
                <!-- Initial Conditions -->
                <div class="parameter-group">
                    <h3>Initial Conditions</h3>
                    <div class="input-row">
                        <label for="v0">Initial Velocity (km/s):</label>
                        <input type="number" id="v0" name="v0" value="3.5" step="0.1" min="1" max="15">
                    </div>
                    <div class="input-row">
                        <label for="gammad0">Initial Flight Path Angle (deg):</label>
                        <input type="number" id="gammad0" name="gammad0" value="0" step="0.1" min="-45" max="45">
                    </div>
                    <div class="input-row">
                        <label for="rolld0">Initial Roll Angle (deg):</label>
                        <input type="number" id="rolld0" name="rolld0" value="0" step="1" min="-90" max="90">
                    </div>
                    <div class="input-row">
                        <label for="kappad0">Initial Heading Angle (deg):</label>
                        <input type="number" id="kappad0" name="kappad0" value="0" step="1" min="-180" max="180">
                    </div>
                    <div class="input-row">
                        <label for="r0">Initial Range (km):</label>
                        <input type="number" id="r0" name="r0" value="0" step="1" min="0" max="1000" readonly>
                    </div>
                    <div class="input-row">
                        <label for="cr0">Initial Crossrange (km):</label>
                        <input type="number" id="cr0" name="cr0" value="0" step="1" min="-1000" max="1000" readonly>
                    </div>
                    <div class="input-row">
                        <label for="t0">Initial Time (s):</label>
                        <input type="number" id="t0" name="t0" value="0" step="1" min="0" max="1000" readonly>
                    </div>
                    
                    <!-- Advanced Settings Toggle -->
                    <div class="input-row">
                        <button type="button" id="advancedSettingsBtn" class="advanced-settings-btn">
                            <span id="advancedSettingsText">Show Advanced Settings</span>
                            <span id="advancedSettingsIcon">▼</span>
                        </button>
                    </div>
                    
                    <!-- Advanced Settings Panel -->
                    <div id="advancedSettingsPanel" class="advanced-settings-panel" style="display: none;">
                        <h4>Roll Angle Time Changes</h4>
                        <div class="roll-changes-info">
                            <p>Define specific times when the roll angle should change during flight:</p>
                        </div>
                        
                        <div id="rollChangesContainer">
                            <!-- Roll angle changes will be added here dynamically -->
                        </div>
                        
                        <button type="button" id="addRollChangeBtn" class="add-roll-change-btn">
                            + Add Roll Change
                        </button>
                    </div>
                </div>

                <!-- Vehicle Properties -->
                <div class="parameter-group">
                    <h3>Vehicle Properties</h3>
                    <div class="input-row">
                        <label for="payload">Payload Mass (kg):</label>
                        <input type="number" id="payload" name="payload" value="1000" step="10" min="100" max="10000">
                    </div>
                    <div class="input-row">
                        <label for="beta">Ballistic Coefficient (kg/m²):</label>
                        <input type="number" id="beta" name="beta" value="4680" step="10" min="100" max="2000">
                    </div>
                    <div class="input-row">
                        <label for="LtoD">Lift-to-Drag Ratio:</label>
                        <input type="number" id="LtoD" name="LtoD" value="2.6" step="0.1" min="0.5" max="10">
                    </div>
                    <!-- <div class="input-row">
                        <label for="emis">Surface Emissivity:</label>
                        <input type="number" id="emis" name="emis" value="0.85" step="0.01" min="0.1" max="1.0">
                    </div> -->
                </div>

                <!-- Thermal Analysis Parameters -->
                <!-- <div class="parameter-group">
                    <h3>Thermal Analysis</h3>
                    <div class="input-row">
                        <label for="distance1">Distance 1 (m):</label>
                        <input type="number" id="distance1" name="distance1" value="1.0" step="0.1" min="0.1" max="10">
                    </div>
                    <div class="input-row">
                        <label for="distance2">Distance 2 (m):</label>
                        <input type="number" id="distance2" name="distance2" value="2.0" step="0.1" min="0.1" max="10">
                    </div>
                </div> -->

                <!-- IR Sensor Wavelengths -->
                <!-- <div class="parameter-group">
                    <h3>IR Sensor Wavelengths</h3>
                    <div class="input-row">
                        <label for="lam1">Band 1 (lower) (μm):</label>
                        <input type="number" id="lam1" name="lam1" value="2.7" step="0.1" min="1" max="20">
                    </div>
                    <div class="input-row">
                        <label for="lam2">Band 1 (upper) (μm):</label>
                        <input type="number" id="lam2" name="lam2" value="2.9" step="0.1" min="1" max="20">
                    </div>
                    <div class="input-row">
                        <label for="lam3">Band 2 (lower) (μm):</label>
                        <input type="number" id="lam3" name="lam3" value="4.2" step="0.1" min="1" max="20">
                    </div>
                    <div class="input-row">
                        <label for="lam4">Band 2 (upper) (μm):</label>
                        <input type="number" id="lam4" name="lam4" value="4.8" step="0.1" min="1" max="20">
                    </div>
                </div> -->

                <!-- Buttons -->
                <div class="button-group">
                    <button type="button" id="runSimulationBtn">Run Simulation</button>
                    <button type="button" id="resetBtn">Reset Parameters</button>
                </div>
            </form>
        </div>

        <!-- Loading indicator -->
        <div id="loading" style="display: none;">
            <p>Running simulation... Please wait.</p>
        </div>

        <!-- Results Section -->
        <div id="results-section" style="display: none;">
            <h2>Simulation Results</h2>
            
            <!-- Summary Statistics -->
            <div id="summary-stats">
                <h3>Summary Statistics</h3>
                <div id="stats-content"></div>
            </div>

            <div id="plots-grid">
                <div class="plot-container">
                    <h3>Altitude vs Range</h3>
                    <div id="plot-altitude-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>Velocity vs Range</h3>
                    <div id="plot-velocity-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>Flight Time vs Range</h3>
                    <div id="plot-time-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>Cross Range vs Range</h3>
                    <div id="plot-crossrange-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <!-- <div class="plot-container">
                    <h3>Temperature 1 vs Range</h3>
                    <div id="plot-t1-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>Temperature 2 vs Range</h3>
                    <div id="plot-t2-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>DSP IR Intensity vs Range</h3>
                    <div id="plot-ir-dsp-range" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div class="plot-container">
                    <h3>SBIRS IR Intensity vs Range</h3>
                    <div id="plot-ir-sbirs-range" style="width: 100%; height: 400px;"></div>
                </div> -->
            </div>

            <!-- Footprint Results Section -->
            <div id="footprint-section" style="display: none;">
                <h2>Footprint Analysis Results</h2>
                
                <div id="footprint-stats">
                    <h3>Footprint Statistics</h3>
                    <div id="footprint-stats-content"></div>
                </div>

                <div class="plot-container">
                    <h3>Glider Footprint</h3>
                    <img id="plot-footprint" src="" alt="Glider Footprint">
                </div>
            </div>

            <div id="map-section" style="display: none;">
                <h2>Footprint Map Projection</h2>
                
                <div class="map-controls">
                    <div class="control-group">
                        <label for="start-latitude">Latitude:</label>
                        <input type="number" id="start-latitude" value="37.7749" step="0.0001" min="-90" max="90">
                    </div>
                    <div class="control-group">
                        <label for="start-longitude">Longitude:</label>
                        <input type="number" id="start-longitude" value="-122.4194" step="0.0001" min="-180" max="180">
                    </div>
                    <div class="control-group">
                        <label for="flight-direction">Flight Direction (°):</label>
                        <input type="number" id="flight-direction" value="90" step="1" min="0" max="359">
                    </div>
                    <button type="button" id="projectFootprintBtn">Project Footprint</button>
                </div>
                
                <div id="map-container">
                    <div id="map"></div>
                    <div class="direction-indicator">
                        Click on map to set start location, or use coordinates above
                    </div>
                    <!-- <div class="footprint-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff4444;"></div>
                            <span>Roll +90° (Right Turn)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #44ff44;"></div>
                            <span>Roll 0° (Straight)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4444ff;"></div>
                            <span>Roll -90° (Left Turn)</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ffaa00;"></div>
                            <span>Roll ±45°</span>
                        </div>
                    </div> -->
                    <div id="map-loading" class="map-loading" style="display: none;">
                        <p>Projecting footprint onto map...</p>
                    </div>
                </div>
            </div>

            <div id="trajectory-map-section" style="display: none;">
                <h2>Flight Trajectory Map</h2>
                
                <div class="trajectory-map-info">
                    <p>This map shows the actual flight path with cross-range deviations based on your roll angle changes.</p>
                </div>
                
                <div class="trajectory-map-controls">
                    <div class="control-group">
                        <label for="trajectory-start-latitude">Start Latitude:</label>
                        <input type="number" id="trajectory-start-latitude" value="37.7749" step="0.0001" min="-90" max="90">
                    </div>
                    <div class="control-group">
                        <label for="trajectory-start-longitude">Start Longitude:</label>
                        <input type="number" id="trajectory-start-longitude" value="-122.4194" step="0.0001" min="-180" max="180">
                    </div>
                    <div class="control-group">
                        <label for="trajectory-flight-direction">Flight Direction (°):</label>
                        <input type="number" id="trajectory-flight-direction" value="90" step="1" min="0" max="359">
                    </div>
                    <button type="button" id="projectTrajectoryBtn">Project Trajectory</button>
                </div>
                
                <div id="trajectory-map-container">
                    <div id="trajectory-map"></div>
                    <div class="trajectory-direction-indicator">
                        Click on map to set start location, or use coordinates above
                    </div>
                    <div class="trajectory-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ff4444; width: 4px; height: 20px;"></div>
                            <span>Flight Path</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #44ff44; width: 8px; height: 8px; border-radius: 50%;"></div>
                            <span>Roll Change Points</span>
                        </div>
                    </div>
                    <div id="trajectory-map-loading" class="map-loading" style="display: none;">
                        <p>Projecting trajectory onto map...</p>
                    </div>
                </div>
            </div>

            <!-- Data Table -->
            <div id="data-table-section">
                <h3>Simulation Data</h3>
                <button id="exportBtn">Export to CSV</button>
                <div id="data-table-container">
                    <table id="data-table">
                        <thead>
                            <tr>
                                <th>Time (s)</th>
                                <th>Altitude (km)</th>
                                <th>Velocity (km/s)</th>
                                <th>Range (km)</th>
                                <th>Crossrange (km)</th>
                                <!-- <th>Boundary Layer</th> -->
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        

        <!-- Error Messages -->
        <div id="error-section" style="display: none;">
            <h3>Error</h3>
            <div id="error-message"></div>
        </div>
    </div>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>

    <script>
        // Default parameters
        const defaultParams = {
            v0: 7.5,
            rolld0: 0,
            gammad0: -2.0,
            kappad0: 0,
            r0: 0,
            cr0: 0,
            t0: 0,
            payload: 1000,
            beta: 500,
            LtoD: 3.0
        };

        // Global variables to store results
        let currentResults = null;
        let map = null;
        let startMarker = null;
        let directionArrow = null;
        let footprintLayers = [];
        let currentFootprintData = null;
        let rollChanges = [];
        let trajectoryMap = null;
        let trajectoryStartMarker = null;
        let trajectoryDirectionArrow = null;
        let trajectoryLayers = [];
        let rollChangeCounter = 0;

        // Initialize event listeners
        document.addEventListener('DOMContentLoaded', function() {
            initializeTrajectoryProjection();
            // document.getElementById('laminarBtn').addEventListener('click', function() {
            //     runSimulation();
            // });
            // document.getElementById('turbulentBtn').addEventListener('click', function() {
            //     runSimulation();
            // });
            // document.getElementById('footprintBtn').addEventListener('click', calculateFootprint);
            document.getElementById('runSimulationBtn').addEventListener('click', runCompleteSimulation);
            document.getElementById('resetBtn').addEventListener('click', resetParameters);
            document.getElementById('exportBtn').addEventListener('click', exportToCSV);

            document.getElementById('advancedSettingsBtn').addEventListener('click', toggleAdvancedSettings);
            document.getElementById('addRollChangeBtn').addEventListener('click', addRollChange);
            document.getElementById('projectTrajectoryBtn').addEventListener('click', projectTrajectoryOnMap);

            document.getElementById('trajectory-start-latitude').addEventListener('change', updateTrajectoryStartLocation);
            document.getElementById('trajectory-start-longitude').addEventListener('change', updateTrajectoryStartLocation);
            document.getElementById('trajectory-flight-direction').addEventListener('input', updateTrajectoryDirection);
        });

        function toggleAdvancedSettings() {
            const panel = document.getElementById('advancedSettingsPanel');
            const text = document.getElementById('advancedSettingsText');
            const icon = document.getElementById('advancedSettingsIcon');
            
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                text.textContent = 'Hide Advanced Settings';
                icon.textContent = '▲';
            } else {
                panel.style.display = 'none';
                text.textContent = 'Show Advanced Settings';
                icon.textContent = '▼';
            }
        }

        function addRollChange() {
            rollChangeCounter++;
            const container = document.getElementById('rollChangesContainer');
            
            const rollChangeDiv = document.createElement('div');
            rollChangeDiv.className = 'roll-change-item';
            rollChangeDiv.id = `roll-change-${rollChangeCounter}`;
            
            rollChangeDiv.innerHTML = `
                <label for="roll-time-${rollChangeCounter}">Time (s):</label>
                <input type="number" id="roll-time-${rollChangeCounter}" name="roll-time-${rollChangeCounter}" 
                    value="10" step="0.1" min="0" max="1000" placeholder="Time in seconds">
                
                <label for="roll-angle-${rollChangeCounter}">Roll Angle (°):</label>
                <input type="number" id="roll-angle-${rollChangeCounter}" name="roll-angle-${rollChangeCounter}" 
                    value="0" step="1" min="-90" max="90" placeholder="Roll angle in degrees">
                
                <button type="button" class="remove-roll-change-btn" onclick="removeRollChange(${rollChangeCounter})">
                    Remove
                </button>
            `;
            
            container.appendChild(rollChangeDiv);
            
            // Update the rollChanges array
            updateRollChangesArray();
        }

        function removeRollChange(id) {
            const element = document.getElementById(`roll-change-${id}`);
            if (element) {
                element.remove();
                updateRollChangesArray();
            }
        }

        function updateRollChangesArray() {
            rollChanges = [];
            const container = document.getElementById('rollChangesContainer');
            const rollChangeItems = container.querySelectorAll('.roll-change-item');
            
            rollChangeItems.forEach(item => {
                const timeInput = item.querySelector('input[id^="roll-time-"]');
                const angleInput = item.querySelector('input[id^="roll-angle-"]');
                
                if (timeInput && angleInput) {
                    const time = parseFloat(timeInput.value);
                    const angle = parseFloat(angleInput.value);
                    
                    if (!isNaN(time) && !isNaN(angle)) {
                        rollChanges.push({ time: time, angle: angle });
                    }
                }
            });
            
            // Sort by time
            rollChanges.sort((a, b) => a.time - b.time);
            
            console.log('Updated roll changes:', rollChanges);
        }

        // Get form data as object
        function getFormData() {
            const form = document.getElementById('simulationForm');
            const formData = new FormData(form);
            const params = {};
            
            for (let [key, value] of formData.entries()) {
                params[key] = parseFloat(value);
            }
            
            // Add roll changes
            updateRollChangesArray();
            params.rollChanges = rollChanges;
            
            return params;
        }

        // Reset form to default parameters
        function resetParameters() {
            for (const [key, value] of Object.entries(defaultParams)) {
                const element = document.getElementById(key);
                if (element) {
                    element.value = value;
                }
            }
            
            // Hide all results sections
            document.getElementById('results-section').style.display = 'none';
            document.getElementById('footprint-section').style.display = 'none';
            document.getElementById('map-section').style.display = 'none';
            document.getElementById('error-section').style.display = 'none';

            // Clear roll changes
            rollChanges = [];
            const container = document.getElementById('rollChangesContainer');
            container.innerHTML = '';
            rollChangeCounter = 0;
            
            // Hide advanced settings
            const panel = document.getElementById('advancedSettingsPanel');
            panel.style.display = 'none';
            document.getElementById('advancedSettingsText').textContent = 'Show Advanced Settings';
            document.getElementById('advancedSettingsIcon').textContent = '▼';
            
            // Hide trajectory map
            document.getElementById('trajectory-map-section').style.display = 'none';
            
            // Clear trajectory map data
            if (trajectoryMap) {
                trajectoryLayers.forEach(layer => trajectoryMap.removeLayer(layer));
                trajectoryLayers = [];
                if (trajectoryStartMarker) {
                    trajectoryMap.removeLayer(trajectoryStartMarker);
                    trajectoryStartMarker = null;
                }
                if (trajectoryDirectionArrow) {
                    trajectoryMap.removeLayer(trajectoryDirectionArrow);
                    if (trajectoryDirectionArrow.arrowHead) {
                        trajectoryMap.removeLayer(trajectoryDirectionArrow.arrowHead);
                    }
                    trajectoryDirectionArrow = null;
                }
            }
            
            // Clear stored data
            currentResults = null;
            currentFootprintData = null;
            
            // Clear map if it exists
            if (map) {
                footprintLayers.forEach(layer => map.removeLayer(layer));
                footprintLayers = [];
                if (startMarker) {
                    map.removeLayer(startMarker);
                    startMarker = null;
                }
                if (directionArrow) {
                    map.removeLayer(directionArrow);
                    if (directionArrow.arrowHead) {
                        map.removeLayer(directionArrow.arrowHead);
                    }
                    directionArrow = null;
                }
            }
        }

        // Show loading indicator
        function showLoading() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('results-section').style.display = 'none';
            document.getElementById('footprint-section').style.display = 'none';
            document.getElementById('error-section').style.display = 'none';
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
        }

        // Show error message
        function showError(message) {
            document.getElementById('error-message').textContent = message;
            document.getElementById('error-section').style.display = 'block';
            hideLoading();
        }

        // Run main simulation
        async function runSimulation() {
            showLoading();
            try {
                const params = getFormData();
                const response = await fetch('/simulate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                const data = await response.json();
                if (data.success) {
                    if (!data.results || !data.results.range || data.results.range.length === 0) {
                        showError("Simulation returned no data.");
                        return;
                    }
                    currentResults = data.results;
                    displayResults(data.results, data.plots);
                    document.getElementById('results-section').style.display = 'block';
                } else {
                    showError(data.error || 'Simulation failed');
                }
            } catch (error) {
                showError('Network error: ' + error.message);
            }
            hideLoading();
        }

        async function runCompleteSimulation() {
            showLoading();
            
            try {
                const params = getFormData();
                
                // Step 1: Run main simulation
                console.log('Running main simulation...');
                const simResponse = await fetch('/simulate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                const simData = await simResponse.json();
                
                if (!simData.success) {
                    showError(simData.error || 'Simulation failed');
                    return;
                }
                
                if (!simData.results || !simData.results.range || simData.results.range.length === 0) {
                    showError("Simulation returned no data.");
                    return;
                }
                
                currentResults = simData.results;
                displayResults(simData.results, simData.plots);
                document.getElementById('results-section').style.display = 'block';
                
                // Step 2: Calculate footprint
                console.log('Calculating footprint...');
                const footprintResponse = await fetch('/footprint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                const footprintData = await footprintResponse.json();
                
                if (!footprintData.success) {
                    showError(footprintData.error || 'Footprint calculation failed');
                    return;
                }
                
                currentFootprintData = footprintData.footprint_data;
                displayFootprintResults(footprintData);
                document.getElementById('footprint-section').style.display = 'block';
                
                // Step 3: Initialize map and project footprint
                console.log('Initializing map and projecting footprint...');
                document.getElementById('map-section').style.display = 'block';
                
                if (!map) {
                    // Initialize map first, then project footprint
                    setTimeout(async () => {
                        initializeMap();
                        // Set initial start location
                        const startLat = parseFloat(document.getElementById('start-latitude').value);
                        const startLng = parseFloat(document.getElementById('start-longitude').value);
                        setStartLocation(startLat, startLng);
                        
                        // Auto-project footprint
                        await projectFootprintOnMap();
                    }, 100);
                } else {
                    // Map already exists, just project footprint
                    await projectFootprintOnMap();
                }

                // Step 4: Show trajectory map if roll changes exist
                if (rollChanges.length > 0) {
                    console.log('Roll changes detected, showing trajectory map...');
                    document.getElementById('trajectory-map-section').style.display = 'block';
                    
                    if (!trajectoryMap) {
                        setTimeout(async () => {
                            initializeTrajectoryMap();
                            const startLat = parseFloat(document.getElementById('trajectory-start-latitude').value);
                            const startLng = parseFloat(document.getElementById('trajectory-start-longitude').value);
                            setTrajectoryStartLocation(startLat, startLng);
                            await projectTrajectoryOnMap();
                        }, 100);
                    } else {
                        await projectTrajectoryOnMap();
                    }
                }
                
                console.log('Complete simulation finished successfully');
                
            } catch (error) {
                showError('Network error: ' + error.message);
                console.error('Error in runCompleteSimulation:', error);
            }
            
            hideLoading();
        }


        // Calculate footprint analysis
        async function calculateFootprint() {
            showLoading();
            
            try {
                const params = getFormData();
                
                const response = await fetch('/footprint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentFootprintData = data.footprint_data;
                    displayFootprintResults(data);
                    document.getElementById('footprint-section').style.display = 'block';
                    
                    // Show map section and initialize if not done
                    document.getElementById('map-section').style.display = 'block';
                    if (!map) {
                        setTimeout(() => {
                            initializeMap();
                            // Set initial start location
                            const startLat = parseFloat(document.getElementById('start-latitude').value);
                            const startLng = parseFloat(document.getElementById('start-longitude').value);
                            setStartLocation(startLat, startLng);
                        }, 100);
                    }
                } else {
                    showError(data.error || 'Footprint calculation failed');
                }
                
            } catch (error) {
                showError('Network error: ' + error.message);
            }
            
            hideLoading();
        }

        // Display simulation results
        function displayResults(results, plots) {
            // Display summary statistics
            displaySummaryStats(results);
            
            // Display plots
            displayPlots(plots);
            
            // Display data table
            displayDataTable(results);
        }

        // Display summary statistics
        function displaySummaryStats(results) {
            const statsContainer = document.getElementById('stats-content');
            
            if (results.range.length === 0) {
                statsContainer.innerHTML = '<p>No simulation data available.</p>';
                return;
            }
            
            const finalIndex = results.range.length - 1;
            const maxAltitude = Math.max(...results.altitude);
            const maxVelocity = Math.max(...results.velocity);
            const finalRange = results.range[finalIndex];
            const finalCrossrange = results.crossrange[finalIndex];
            const flightTime = results.time[finalIndex];
            
            statsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <strong>Final Range:</strong> ${finalRange.toFixed(2)} km
                    </div>
                    <div class="stat-item">
                        <strong>Final Crossrange:</strong> ${finalCrossrange.toFixed(2)} km
                    </div>
                    <div class="stat-item">
                        <strong>Flight Time:</strong> ${flightTime.toFixed(1)} s
                    </div>
                    <div class="stat-item">
                        <strong>Max Altitude:</strong> ${maxAltitude.toFixed(2)} km
                    </div>
                    <div class="stat-item">
                        <strong>Max Velocity:</strong> ${maxVelocity.toFixed(2)} km/s
                    </div>
                </div>
            `;
        }

        function displayPlots(plots) {
            // Create interactive plots instead of displaying images
            createInteractivePlot('plot-altitude-range', currentResults.range, currentResults.altitude, 
                                'Range (km)', 'Altitude (km)', 'Altitude vs Range');
            
            createInteractivePlot('plot-velocity-range', currentResults.range, currentResults.velocity, 
                                'Range (km)', 'Velocity (km/s)', 'Velocity vs Range');
            
            createInteractivePlot('plot-time-range', currentResults.range, currentResults.time, 
                                'Range (km)', 'Time (s)', 'Flight Time vs Range');
            
            createInteractivePlot('plot-crossrange-range', currentResults.range, currentResults.crossrange, 
                                'Range (km)', 'Crossrange (km)', 'Cross Range vs Range');
        }

        // Create interactive plot with crosshairs and tooltips
        function createInteractivePlot(containerId, xData, yData, xTitle, yTitle, plotTitle) {
            const trace = {
                x: xData,
                y: yData,
                type: 'scatter',
                mode: 'lines',
                line: { color: '#1f77b4', width: 2 },
                hovertemplate: `<b>${xTitle}:</b> %{x:.3f}<br><b>${yTitle}:</b> %{y:.3f}<extra></extra>`
            };

            const layout = {
                title: {
                    text: plotTitle,
                    font: { size: 16 }
                },
                xaxis: {
                    title: xTitle,
                    showgrid: true,
                    gridcolor: '#ddd',
                    showspikes: true,
                    spikecolor: '#999',
                    spikethickness: 1,
                    spikedash: 'dot',
                    spikemode: 'across'
                },
                yaxis: {
                    title: yTitle,
                    showgrid: true,
                    gridcolor: '#ddd',
                    showspikes: true,
                    spikecolor: '#999',
                    spikethickness: 1,
                    spikedash: 'dot',
                    spikemode: 'across'
                },
                hovermode: 'closest',
                showlegend: false,
                margin: { l: 60, r: 40, t: 60, b: 60 },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };

            const config = {
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'select2d', 'lasso2d', 'autoScale2d'],
                displaylogo: false,
                responsive: true
            };

            Plotly.newPlot(containerId, [trace], layout, config);
        }

        // Display data table
        function displayDataTable(results) {
            const tbody = document.querySelector('#data-table tbody');
            tbody.innerHTML = '';
            
            for (let i = 0; i < results.time.length; i++) {
                const row = tbody.insertRow();
                
                const cells = [
                    results.time[i].toFixed(1),
                    results.altitude[i].toFixed(3),
                    results.velocity[i].toFixed(3),
                    results.range[i].toFixed(3),
                    results.crossrange[i].toFixed(3),
                    // results.boundary_layer[i]
                ];
                
                cells.forEach(cellData => {
                    const cell = row.insertCell();
                    cell.textContent = cellData;
                });
            }
        }

        // Display footprint results
        function displayFootprintResults(data) {
            const statsContainer = document.getElementById('footprint-stats-content');
            
            statsContainer.innerHTML = `
                <div class="stats-grid">
                    <div class="stat-item">
                        <strong>Footprint Area:</strong> ${data.footprint_area.toLocaleString()} km²
                    </div>
                    <div class="stat-item">
                        <strong>Trajectories Calculated:</strong> ${data.trajectories_count}
                    </div>
                </div>
            `;
            
            // Display footprint plot
            if (data.plot) {
                const plotElement = document.getElementById('plot-footprint');
                plotElement.src = 'data:image/png;base64,' + data.plot;
                plotElement.style.display = 'block';
            }
        }

        // Export results to CSV
        function exportToCSV() {
            if (!currentResults) {
                alert('No simulation data available to export.');
                return;
            }
            
            const headers = [
                'Time (s)', 'Altitude (km)', 'Velocity (km/s)', 'Range (km)', 
                'Crossrange (km)', 'Pathlength (km)', 'Gamma (deg)', 'Kappa (deg)'
                // Remove 'Boundary_Layer' from headers
            ];
            
            let csvContent = headers.join(',') + '\n';
            
            for (let i = 0; i < currentResults.time.length; i++) {
                const row = [
                    currentResults.time[i],
                    currentResults.altitude[i],
                    currentResults.velocity[i],
                    currentResults.range[i],
                    currentResults.crossrange[i],
                    currentResults.pathlength[i],
                    currentResults.gamma_deg[i],
                    currentResults.kappa_deg[i]
                    // Remove currentResults.boundary_layer[i]
                ];
                csvContent += row.join(',') + '\n';
            }
            
            // Download CSV file
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hypersonic_simulation_results.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Initialize the map
        function initializeMap() {
            if (map) {
                map.remove();
            }
            
            map = L.map('map').setView([37.7749, -122.4194], 8);
            
            // Add OpenStreetMap tiles
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);
            
            // Add click handler for setting start location
            map.on('click', function(e) {
                setStartLocation(e.latlng.lat, e.latlng.lng);
            });
        }

        // Set start location on map
        function setStartLocation(lat, lng) {
            // Update input fields
            document.getElementById('start-latitude').value = lat.toFixed(6);
            document.getElementById('start-longitude').value = lng.toFixed(6);
            
            // Remove existing marker
            if (startMarker) {
                map.removeLayer(startMarker);
            }
            
            // Add new marker
            startMarker = L.marker([lat, lng], {
                draggable: true,
                title: 'Start Location'
            }).addTo(map);
            
            // Handle marker drag
            startMarker.on('dragend', function(e) {
                const position = e.target.getLatLng();
                setStartLocation(position.lat, position.lng);
            });
            
            updateDirectionArrow();
        }

        // Update direction arrow
        function updateDirectionArrow() {
            if (!startMarker) return;
            
            const startPos = startMarker.getLatLng();
            const direction = parseFloat(document.getElementById('flight-direction').value);
            
            // Calculate end point for arrow (50km ahead)
            const endPos = calculateDestination(startPos.lat, startPos.lng, direction, 50);
            
            // Remove existing arrow
            if (directionArrow) {
                map.removeLayer(directionArrow);
            }
            
            // Create direction arrow
            directionArrow = L.polyline([
                [startPos.lat, startPos.lng],
                [endPos.lat, endPos.lng]
            ], {
                color: '#667eea',
                weight: 4,
                opacity: 0.8
            }).addTo(map);
            
            // Add arrowhead
            const arrowHead = L.marker([endPos.lat, endPos.lng], {
                icon: L.divIcon({
                    html: '➤',
                    iconSize: [20, 20],
                    className: 'arrow-icon',
                    iconAnchor: [10, 10]
                })
            }).addTo(map);
            
            // Group arrow components
            directionArrow.arrowHead = arrowHead;
        }

        // Calculate destination point given start point, bearing and distance
        function calculateDestination(lat1, lon1, bearing, distance) {
            const R = 6371; // Earth's radius in km
            const φ1 = lat1 * Math.PI / 180;
            const λ1 = lon1 * Math.PI / 180;
            const θ = bearing * Math.PI / 180;
            
            const φ2 = Math.asin(Math.sin(φ1) * Math.cos(distance / R) +
                                Math.cos(φ1) * Math.sin(distance / R) * Math.cos(θ));
            
            const λ2 = λ1 + Math.atan2(Math.sin(θ) * Math.sin(distance / R) * Math.cos(φ1),
                                    Math.cos(distance / R) - Math.sin(φ1) * Math.sin(φ2));
            
            return {
                lat: φ2 * 180 / Math.PI,
                lng: λ2 * 180 / Math.PI
            };
        }

        // Calculate bearing between two points
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const φ1 = lat1 * Math.PI / 180;
            const φ2 = lat2 * Math.PI / 180;
            const Δλ = (lon2 - lon1) * Math.PI / 180;
            
            const y = Math.sin(Δλ) * Math.cos(φ2);
            const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
            
            const θ = Math.atan2(y, x);
            return (θ * 180 / Math.PI + 360) % 360;
        }

        // Project footprint onto map
        async function projectFootprintOnMap() {
            console.log("=== Starting projectFootprintOnMap ===");
            
            if (!currentFootprintData) {
                console.error("No currentFootprintData available");
                alert('Please calculate footprint first before projecting on map.');
                return;
            }
            
            // Deep debug of the footprint data structure
            console.log('currentFootprintData keys:', Object.keys(currentFootprintData));
            console.log('Full currentFootprintData:', JSON.stringify(currentFootprintData, null, 2));
            
            const startLat = parseFloat(document.getElementById('start-latitude').value);
            const startLng = parseFloat(document.getElementById('start-longitude').value);
            const flightDirection = parseFloat(document.getElementById('flight-direction').value);
            
            console.log(`Coordinates: lat=${startLat}, lng=${startLng}, direction=${flightDirection}`);
            
            if (isNaN(startLat) || isNaN(startLng) || isNaN(flightDirection)) {
                alert('Please enter valid coordinates and flight direction.');
                return;
            }
            
            document.getElementById('map-loading').style.display = 'flex';
            
            try {
                // Clear existing footprint layers
                footprintLayers.forEach(layer => map.removeLayer(layer));
                footprintLayers = [];
                
                // Check the structure of currentFootprintData
                console.log('Checking currentFootprintData.curves:', currentFootprintData.curves);
                
                if (!currentFootprintData.curves) {
                    console.error('currentFootprintData.curves is undefined or null');
                    alert('No curves found in footprint data. Data structure issue.');
                    return;
                }
                
                if (Object.keys(currentFootprintData.curves).length === 0) {
                    console.error('currentFootprintData.curves is empty object');
                    alert('No curves found in footprint data. Empty curves object.');
                    return;
                }
                
                // Get all available roll angles - handle both string and numeric keys
                const curveKeys = Object.keys(currentFootprintData.curves);
                console.log('Raw curve keys:', curveKeys);
                
                const availableRollAngles = curveKeys.map(angle => {
                    const parsed = parseFloat(angle);
                    console.log(`Parsing angle key "${angle}" -> ${parsed}`);
                    return parsed;
                }).filter(angle => !isNaN(angle));
                
                console.log('Parsed roll angles:', availableRollAngles);
                
                availableRollAngles.sort((a, b) => a - b);
                console.log('Sorted roll angles:', availableRollAngles);
                
                // Check if 0 degree is present
                const hasZeroDegree = availableRollAngles.some(angle => Math.abs(angle) < 0.001);
                console.log('Has 0 degree angle:', hasZeroDegree);
                
                // Generate colors
                const colors = generateColors(availableRollAngles.length);
                console.log('Generated colors:', colors);
                
                let curvesProcessed = 0;
                let curvesAdded = 0;
                
                for (let i = 0; i < availableRollAngles.length; i++) {
                    const rollAngle = availableRollAngles[i];
                    
                    // Try multiple key formats to find the curve data
                    let footprintCurve = null;
                    let keyUsed = null;
                    
                    // Try different key formats
                    const possibleKeys = [
                        rollAngle.toString(),
                        rollAngle.toFixed(1),
                        rollAngle.toFixed(0),
                        Math.round(rollAngle).toString(),
                        rollAngle
                    ];
                    
                    for (const key of possibleKeys) {
                        if (currentFootprintData.curves[key]) {
                            footprintCurve = currentFootprintData.curves[key];
                            keyUsed = key;
                            break;
                        }
                    }
                    
                    console.log(`\n--- Processing roll angle ${rollAngle} (${i+1}/${availableRollAngles.length}) ---`);
                    console.log('Key used:', keyUsed);
                    console.log('Curve data found:', !!footprintCurve);
                    
                    curvesProcessed++;
                    
                    if (!footprintCurve) {
                        console.warn(`No curve data for roll angle ${rollAngle} - tried keys:`, possibleKeys);
                        continue;
                    }
                    
                    if (!Array.isArray(footprintCurve)) {
                        console.warn(`Curve data for roll angle ${rollAngle} is not an array:`, typeof footprintCurve);
                        continue;
                    }
                    
                    if (footprintCurve.length === 0) {
                        console.warn(`Empty curve for roll angle ${rollAngle}`);
                        continue;
                    }
                    
                    console.log(`Curve has ${footprintCurve.length} points`);
                    console.log('First few points:', footprintCurve.slice(0, 3));
                    
                    // Validate point structure
                    let validPoints = true;
                    for (let j = 0; j < Math.min(3, footprintCurve.length); j++) {
                        const point = footprintCurve[j];
                        if (!point || typeof point.range !== 'number' || typeof point.crossrange !== 'number') {
                            console.error(`Invalid point structure at index ${j}:`, point);
                            validPoints = false;
                            break;
                        }
                    }
                    
                    if (!validPoints) {
                        console.warn(`Skipping roll angle ${rollAngle} due to invalid point structure`);
                        continue;
                    }
                    
                    try {
                        const projectedPoints = projectFootprintCurve(
                            footprintCurve, startLat, startLng, flightDirection, rollAngle
                        );
                        
                        console.log(`Projection result for ${rollAngle}°:`, projectedPoints);
                        
                        const curve = projectedPoints.curve;
                        
                        // Add curve to map
                        if (curve && curve.length > 0) {
                            console.log(`Adding curve for ${rollAngle}° with ${curve.length} points`);
                            
                            // Special styling for 0-degree line (centerline)
                            const isZeroDegree = Math.abs(rollAngle) < 0.001;
                            
                            const polyline = L.polyline(curve, {
                                color: isZeroDegree ? '#FF0000' : colors[i], // Red for centerline
                                weight: isZeroDegree ? 4 : 3, // Thicker for centerline
                                opacity: isZeroDegree ? 1.0 : 0.8,
                                dashArray: isZeroDegree ? null : '5, 5' // Solid line for centerline
                            }).addTo(map);
                            
                            polyline.bindTooltip(`Roll: ${rollAngle}°${isZeroDegree ? ' (Centerline)' : ''}`);
                            footprintLayers.push(polyline);
                            curvesAdded++;
                        } else {
                            console.warn(`No valid curve for roll angle ${rollAngle}`);
                        }
                        
                    } catch (projectionError) {
                        console.error(`Error projecting curve for roll angle ${rollAngle}:`, projectionError);
                    }
                }
                
                console.log(`\n=== Summary ===`);
                console.log(`Curves processed: ${curvesProcessed}`);
                console.log(`Curves added to map: ${curvesAdded}`);
                console.log(`Total footprint layers: ${footprintLayers.length}`);
                
                // Fit map to show all footprint data
                if (footprintLayers.length > 0) {
                    const group = new L.featureGroup(footprintLayers);
                    const bounds = group.getBounds();
                    console.log('Fitting map to bounds:', bounds);
                    map.fitBounds(bounds.pad(0.1));
                    console.log('Map fitted successfully');
                } else {
                    console.error('No footprint layers to display on map');
                    alert('No footprint curves could be projected to the map. Check console for details.');
                }
                
            } catch (error) {
                console.error('Error in projectFootprintOnMap:', error);
                alert('Error projecting footprint: ' + error.message);
            }
            
            document.getElementById('map-loading').style.display = 'none';
            console.log("=== Finished projectFootprintOnMap ===");
        }

        // Updated projection function to handle single curves properly
        function projectFootprintCurve(footprintCurve, startLat, startLng, flightDirection, rollAngle) {
            console.log(`  Projecting curve for roll ${rollAngle}° with ${footprintCurve.length} points`);
            
            const curve = [];
            
            for (let i = 0; i < footprintCurve.length; i++) {
                const point = footprintCurve[i];
                const range = point.range;
                let crossrange = point.crossrange;
                
                // For negative roll angles, ensure crossrange reflects the correct side
                if (rollAngle < 0 && crossrange > 0) {
                    crossrange = -crossrange;
                }
                
                if (i < 3) {
                    console.log(`  Point ${i}: range=${range}km, crossrange=${crossrange}km`);
                }
                
                // Calculate position along flight path
                const flightPathPoint = calculateDestination(startLat, startLng, flightDirection, range);
                
                if (i < 3) {
                    console.log(`  Flight path point ${i}:`, flightPathPoint);
                }
                
                // For zero crossrange (centerline), just use the flight path point
                if (Math.abs(crossrange) < 0.001) {
                    curve.push([flightPathPoint.lat, flightPathPoint.lng]);
                    if (i < 3) {
                        console.log(`  Centerline point ${i}:`, flightPathPoint);
                    }
                } else {
                    // Calculate perpendicular bearing based on crossrange sign
                    const perpBearing = crossrange > 0 ? 
                        (flightDirection + 90) % 360 : // Right side (positive crossrange)
                        (flightDirection - 90 + 360) % 360; // Left side (negative crossrange)
                    
                    // Project crossrange perpendicular to flight path
                    const projectedPoint = calculateDestination(
                        flightPathPoint.lat, flightPathPoint.lng, 
                        perpBearing, Math.abs(crossrange)
                    );
                    
                    curve.push([projectedPoint.lat, projectedPoint.lng]);
                    
                    if (i < 3) {
                        console.log(`  Projected point ${i}:`, projectedPoint);
                    }
                }
            }
            
            console.log(`  Projection complete: ${curve.length} points`);
            
            return { curve: curve };
        }

        // Helper function to generate distinct colors
        function generateColors(count) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                const hue = (i * 360 / count) % 360;
                colors.push(`hsl(${hue}, 70%, 50%)`);
            }
            return colors;
        }

        // Helper function to calculate destination point
        function calculateDestination(lat1, lng1, bearing, distance) {
            const R = 6371; // Earth's radius in kilometers
            const lat1Rad = lat1 * Math.PI / 180;
            const lng1Rad = lng1 * Math.PI / 180;
            const bearingRad = bearing * Math.PI / 180;
            const distanceRatio = distance / R;
            
            const lat2Rad = Math.asin(
                Math.sin(lat1Rad) * Math.cos(distanceRatio) +
                Math.cos(lat1Rad) * Math.sin(distanceRatio) * Math.cos(bearingRad)
            );
            
            const lng2Rad = lng1Rad + Math.atan2(
                Math.sin(bearingRad) * Math.sin(distanceRatio) * Math.cos(lat1Rad),
                Math.cos(distanceRatio) - Math.sin(lat1Rad) * Math.sin(lat2Rad)
            );
            
            return {
                lat: lat2Rad * 180 / Math.PI,
                lng: lng2Rad * 180 / Math.PI
            };
        }

        // Initialize trajectory map
        function initializeTrajectoryMap() {
            if (trajectoryMap) {
                trajectoryMap.remove();
            }
            
            trajectoryMap = L.map('trajectory-map').setView([37.7749, -122.4194], 8);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(trajectoryMap);
            
            trajectoryMap.on('click', function(e) {
                setTrajectoryStartLocation(e.latlng.lat, e.latlng.lng);
            });
        }

        // Set trajectory start location
        function setTrajectoryStartLocation(lat, lng) {
            document.getElementById('trajectory-start-latitude').value = lat.toFixed(6);
            document.getElementById('trajectory-start-longitude').value = lng.toFixed(6);
            
            if (trajectoryStartMarker) {
                trajectoryMap.removeLayer(trajectoryStartMarker);
            }
            
            trajectoryStartMarker = L.marker([lat, lng], {
                draggable: true,
                title: 'Trajectory Start Location'
            }).addTo(trajectoryMap);
            
            trajectoryStartMarker.on('dragend', function(e) {
                const position = e.target.getLatLng();
                setTrajectoryStartLocation(position.lat, position.lng);
            });
            
            updateTrajectoryDirection();
        }

        // Update trajectory start location from input
        function updateTrajectoryStartLocation() {
            const lat = parseFloat(document.getElementById('trajectory-start-latitude').value);
            const lng = parseFloat(document.getElementById('trajectory-start-longitude').value);
            if (!isNaN(lat) && !isNaN(lng)) {
                setTrajectoryStartLocation(lat, lng);
                if (trajectoryMap) {
                    trajectoryMap.setView([lat, lng], trajectoryMap.getZoom());
                }
            }
        }

        // Update trajectory direction arrow
        function updateTrajectoryDirection() {
            if (!trajectoryStartMarker) return;
            
            const startPos = trajectoryStartMarker.getLatLng();
            const direction = parseFloat(document.getElementById('trajectory-flight-direction').value);
            
            const endPos = calculateDestination(startPos.lat, startPos.lng, direction, 50);
            
            if (trajectoryDirectionArrow) {
                trajectoryMap.removeLayer(trajectoryDirectionArrow);
            }
            
            trajectoryDirectionArrow = L.polyline([
                [startPos.lat, startPos.lng],
                [endPos.lat, endPos.lng]
            ], {
                color: '#667eea',
                weight: 4,
                opacity: 0.8
            }).addTo(trajectoryMap);
            
            const arrowHead = L.marker([endPos.lat, endPos.lng], {
                icon: L.divIcon({
                    html: '➤',
                    iconSize: [20, 20],
                    className: 'arrow-icon',
                    iconAnchor: [10, 10]
                })
            }).addTo(trajectoryMap);
            
            trajectoryDirectionArrow.arrowHead = arrowHead;
        }

        // Project trajectory on map
        async function projectTrajectoryOnMap() {
            if (!currentResults) {
                alert('Please run simulation first before projecting trajectory.');
                return;
            }
            
            if (rollChanges.length === 0) {
                alert('No roll angle changes defined. Add roll changes in Advanced Settings.');
                return;
            }
            
            console.log('Roll changes being applied:', rollChanges);
            
            // Add null checks for DOM elements
            const startLatElement = document.getElementById('trajectory-start-latitude');
            const startLngElement = document.getElementById('trajectory-start-longitude');
            const flightDirectionElement = document.getElementById('trajectory-flight-direction');
            
            if (!startLatElement || !startLngElement || !flightDirectionElement) {
                alert('Error: Required input elements not found. Please check that the trajectory input fields exist in your HTML.');
                console.error('Missing elements:', {
                    'trajectory-start-latitude': startLatElement,
                    'trajectory-start-longitude': startLngElement,
                    'trajectory-flight-direction': flightDirectionElement
                });
                return;
            }
            
            const startLat = parseFloat(startLatElement.value);
            const startLng = parseFloat(startLngElement.value);
            const flightDirection = parseFloat(flightDirectionElement.value);
            
            if (isNaN(startLat) || isNaN(startLng) || isNaN(flightDirection)) {
                alert('Please enter valid coordinates and flight direction.');
                return;
            }
            
            // Check if loading element exists
            const loadingElement = document.getElementById('trajectory-map-loading');
            if (loadingElement) {
                loadingElement.style.display = 'flex';
            }
            
            try {
                // Clear existing trajectory layers
                if (typeof trajectoryLayers !== 'undefined' && trajectoryLayers.length > 0) {
                    trajectoryLayers.forEach(layer => {
                        if (trajectoryMap && trajectoryMap.hasLayer(layer)) {
                            trajectoryMap.removeLayer(layer);
                        }
                    });
                    trajectoryLayers = [];
                }
                
                // **FIX: Re-run simulation with roll changes to get updated trajectory**
                const simulationParams = getSimulationParameters();
                simulationParams.rollChanges = rollChanges; // Include the roll changes
                
                console.log('Simulation parameters being sent:', simulationParams);
                console.log('Roll changes in simulation params:', simulationParams.rollChanges);
                
                const response = await fetch('/simulate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(simulationParams)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data.success) {
                    throw new Error(data.error || 'Simulation failed');
                }
                
                // Use the NEW results that include roll changes
                const trajectoryResults = data.results;
                
                console.log('Trajectory results received:', {
                    rangePoints: trajectoryResults.range.length,
                    crossrangePoints: trajectoryResults.crossrange.length,
                    timePoints: trajectoryResults.time.length,
                    maxCrossrange: Math.max(...trajectoryResults.crossrange),
                    minCrossrange: Math.min(...trajectoryResults.crossrange)
                });
                
                // Check if trajectoryMap exists
                if (typeof trajectoryMap === 'undefined' || !trajectoryMap) {
                    throw new Error('Trajectory map not initialized');
                }
                
                // Create trajectory path from NEW simulation results
                const trajectoryPoints = [];
                const rollChangePoints = [];
                
                // Sort roll changes by time for easier processing
                const sortedRollChanges = [...rollChanges].sort((a, b) => a.time - b.time);
                
                for (let i = 0; i < trajectoryResults.range.length; i++) {
                    const range = trajectoryResults.range[i];
                    const crossrange = trajectoryResults.crossrange[i];
                    const time = trajectoryResults.time[i];
                    
                    // Calculate position along flight path
                    const flightPathPoint = calculateDestination(startLat, startLng, flightDirection, range);
                    
                    // Apply crossrange offset
                    if (Math.abs(crossrange) < 0.001) {
                        trajectoryPoints.push([flightPathPoint.lat, flightPathPoint.lng]);
                    } else {
                        const perpBearing = crossrange > 0 ? 
                            (flightDirection + 90) % 360 : 
                            (flightDirection - 90 + 360) % 360;
                        
                        const projectedPoint = calculateDestination(
                            flightPathPoint.lat, flightPathPoint.lng, 
                            perpBearing, Math.abs(crossrange)
                        );
                        
                        trajectoryPoints.push([projectedPoint.lat, projectedPoint.lng]);
                    }
                }
                
                // **FIXED: Find roll change points using interpolation**
                // Instead of looking for exact time matches, interpolate to find the closest trajectory points
                for (const rollChange of sortedRollChanges) {
                    const targetTime = rollChange.time;
                    
                    // Find the closest time points in the trajectory
                    let closestIndex = 0;
                    let minTimeDiff = Math.abs(trajectoryResults.time[0] - targetTime);
                    
                    for (let i = 1; i < trajectoryResults.time.length; i++) {
                        const timeDiff = Math.abs(trajectoryResults.time[i] - targetTime);
                        if (timeDiff < minTimeDiff) {
                            minTimeDiff = timeDiff;
                            closestIndex = i;
                        }
                    }
                    
                    // If we found a reasonably close point (within 30 seconds), mark it
                    if (minTimeDiff < 30) {
                        rollChangePoints.push({
                            point: trajectoryPoints[closestIndex],
                            time: rollChange.time,
                            angle: rollChange.angle,
                            actualTime: trajectoryResults.time[closestIndex],
                            timeDiff: minTimeDiff
                        });
                        
                        console.log(`Roll change at ${rollChange.time}s mapped to trajectory point at ${trajectoryResults.time[closestIndex]}s (diff: ${minTimeDiff.toFixed(1)}s)`);
                    } else {
                        console.warn(`Roll change at ${rollChange.time}s is too far from any trajectory point (closest: ${minTimeDiff.toFixed(1)}s)`);
                    }
                }
                
                console.log('Trajectory points generated:', trajectoryPoints.length);
                console.log('Roll change points found:', rollChangePoints.length);
                
                // Initialize trajectoryLayers if not exists
                if (typeof trajectoryLayers === 'undefined') {
                    trajectoryLayers = [];
                }
                
                // Add trajectory path to map
                if (trajectoryPoints.length > 0) {
                    const trajectoryPath = L.polyline(trajectoryPoints, {
                        color: '#ff4444',
                        weight: 4,
                        opacity: 0.8
                    }).addTo(trajectoryMap);
                    
                    trajectoryPath.bindTooltip('Flight Trajectory (with Roll Changes)');
                    trajectoryLayers.push(trajectoryPath);
                }
                
                // Add roll change points
                rollChangePoints.forEach(point => {
                    const marker = L.circleMarker(point.point, {
                        color: '#44ff44',
                        fillColor: '#44ff44',
                        fillOpacity: 0.8,
                        radius: 8,
                        weight: 2
                    }).addTo(trajectoryMap);
                    
                    marker.bindTooltip(`Planned: ${point.time}s<br>Actual: ${point.actualTime.toFixed(1)}s<br>Roll: ${point.angle}°`);
                    trajectoryLayers.push(marker);
                });
                
                // Fit map to show trajectory
                if (trajectoryLayers.length > 0) {
                    const group = new L.featureGroup(trajectoryLayers);
                    trajectoryMap.fitBounds(group.getBounds().pad(0.1));
                }
                
                console.log('Trajectory projection completed with roll changes');
                
            } catch (error) {
                console.error('Error projecting trajectory:', error);
                alert('Error projecting trajectory: ' + error.message);
            }
            
            // Hide loading element
            if (loadingElement) {
                loadingElement.style.display = 'none';
            }
        }

        // Helper function to get current simulation parameters
        function getSimulationParameters() {
            // Add null checks for all simulation parameter elements using correct IDs
            const elements = {
                'v0': document.getElementById('v0'),
                'rolld0': document.getElementById('rolld0'),
                'gammad0': document.getElementById('gammad0'),
                'kappad0': document.getElementById('kappad0'),
                'payload': document.getElementById('payload'),
                'beta': document.getElementById('beta'),
                'LtoD': document.getElementById('LtoD')
            };
            
            // Check if any elements are missing
            const missingElements = Object.keys(elements).filter(key => !elements[key]);
            if (missingElements.length > 0) {
                console.error('Missing simulation parameter elements:', missingElements);
                throw new Error(`Missing required elements: ${missingElements.join(', ')}`);
            }
            
            return {
                v0: parseFloat(elements['v0'].value) || 0,
                rolld0: parseFloat(elements['rolld0'].value) || 0,
                gammad0: parseFloat(elements['gammad0'].value) || 0,
                kappad0: parseFloat(elements['kappad0'].value) || 0,
                payload: parseFloat(elements['payload'].value) || 0,
                beta: parseFloat(elements['beta'].value) || 0,
                LtoD: parseFloat(elements['LtoD'].value) || 0,
                r0: 0,   
                cr0: 0,  
                t0: 0    
            };
        }

        // Helper function to check if required elements exist
        function checkRequiredElements() {
            const requiredElements = [
                'trajectory-start-latitude',
                'trajectory-start-longitude',
                'trajectory-flight-direction',
                'trajectory-map-loading',
                'v0',
                'rolld0',
                'gammad0',
                'kappad0',
                'payload',
                'beta',
                'LtoD'
            ];
            
            const missingElements = [];
            
            requiredElements.forEach(id => {
                if (!document.getElementById(id)) {
                    missingElements.push(id);
                }
            });
            
            if (missingElements.length > 0) {
                console.error('Missing required HTML elements:', missingElements);
                return false;
            }
            
            return true;
        }

        // Function to initialize trajectory projection (call this after DOM is loaded)
        function initializeTrajectoryProjection() {
            if (!checkRequiredElements()) {
                console.error('Cannot initialize trajectory projection: missing required elements');
                return false;
            }
            
            // Initialize variables if they don't exist
            if (typeof trajectoryLayers === 'undefined') {
                window.trajectoryLayers = [];
            }
            
            if (typeof rollChanges === 'undefined') {
                window.rollChanges = [];
            }
            
            return true;
        }

        function debugRollChanges() {
            console.log('Current roll changes:', rollChanges);
            console.log('Roll changes length:', rollChanges.length);
            
            if (rollChanges.length > 0) {
                rollChanges.forEach((change, index) => {
                    console.log(`Roll change ${index}:`, {
                        time: change.time,
                        angle: change.angle,
                        timeType: typeof change.time,
                        angleType: typeof change.angle
                    });
                });
            }
        }

        debugRollChanges();

        // Function to manually add a test roll change
        function addTestRollChange() {
            if (typeof rollChanges === 'undefined') {
                window.rollChanges = [];
            }
            
            const testChange = {
                time: 60,
                angle: 90
            };
            
            rollChanges.push(testChange);
            console.log('Added test roll change:', testChange);
            console.log('Current roll changes:', rollChanges);
            
            return testChange;
        }

        // Function to verify roll changes are being sent to server
        function testSimulationWithRollChanges() {
            const simulationParams = getSimulationParameters();
            simulationParams.rollChanges = rollChanges;
            
            console.log('Test simulation parameters:', simulationParams);
            console.log('Roll changes in params:', simulationParams.rollChanges);
            
            // Log the JSON that would be sent to server
            console.log('JSON to be sent to server:', JSON.stringify(simulationParams, null, 2));
        }

        // Function to compare trajectories with and without roll changes
        async function compareTrajectories() {
            if (!currentResults) {
                console.error('No current results available');
                return;
            }
            
            console.log('Original trajectory (without roll changes):');
            console.log('Max crossrange:', Math.max(...currentResults.crossrange));
            console.log('Min crossrange:', Math.min(...currentResults.crossrange));
            console.log('Crossrange at end:', currentResults.crossrange[currentResults.crossrange.length - 1]);
            
            // Now test with roll changes
            if (rollChanges.length > 0) {
                try {
                    const simulationParams = getSimulationParameters();
                    simulationParams.rollChanges = rollChanges;
                    
                    const response = await fetch('/simulate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(simulationParams)
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (!data.success) {
                        throw new Error(data.error || 'Simulation failed');
                    }
                    
                    console.log('New trajectory (with roll changes):');
                    console.log('Max crossrange:', Math.max(...data.results.crossrange));
                    console.log('Min crossrange:', Math.min(...data.results.crossrange));
                    console.log('Crossrange at end:', data.results.crossrange[data.results.crossrange.length - 1]);
                    
                } catch (error) {
                    console.error('Error in trajectory comparison:', error);
                }
            }
        }

        // Function to check if server is processing roll changes
        function checkServerRollProcessing() {
            console.log('Checking server roll change processing...');
            
            // Check if the server endpoint exists and responds
            fetch('/simulate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    v0: 3.5,
                    rolld0: 0,
                    gammad0: 0,
                    kappad0: 0,
                    payload: 1000,
                    beta: 4680,
                    LtoD: 2.6,
                    r0: 0,
                    cr0: 0,
                    t0: 0,
                    rollChanges: [{time: 60, angle: 90}]
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('Server response to roll changes test:', data);
                if (data.success) {
                    console.log('Server processed roll changes successfully');
                } else {
                    console.error('Server failed to process roll changes:', data.error);
                }
            })
            .catch(error => {
                console.error('Error testing server roll processing:', error);
            });
        }
        
        async function calculateFootprint() {
            showLoading();
            
            try {
                const params = getFormData();
                
                const response = await fetch('/footprint', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(params)
                });
                
                const data = await response.json();
                
                if (data.success) {
                    currentFootprintData = data.footprint_data; // Store for map projection
                    displayFootprintResults(data);
                    document.getElementById('footprint-section').style.display = 'block';
                    
                    // Show map section and initialize if not done
                    document.getElementById('map-section').style.display = 'block';
                    if (!map) {
                        setTimeout(initializeMap, 100); // Small delay to ensure container is visible
                    }
                } else {
                    showError(data.error || 'Footprint calculation failed');
                }
                
            } catch (error) {
                showError('Network error: ' + error.message);
            }
            
            hideLoading();
        }

        // Add event listeners for map functionality
        document.addEventListener('DOMContentLoaded', function() {
            initializeTrajectoryProjection();
            // Existing event listeners...
            // document.getElementById('laminarBtn').addEventListener('click', function() {
            //     runSimulation();
            // });
            // document.getElementById('turbulentBtn').addEventListener('click', function() {
            //     runSimulation();
            // });
            // document.getElementById('footprintBtn').addEventListener('click', calculateFootprint);
            document.getElementById('runSimulationBtn').addEventListener('click', runCompleteSimulation);
            document.getElementById('resetBtn').addEventListener('click', resetParameters);
            document.getElementById('exportBtn').addEventListener('click', exportToCSV);
            
            // New map event listeners
            document.getElementById('projectFootprintBtn').addEventListener('click', projectFootprintOnMap);
            
            // Update direction arrow when flight direction changes
            document.getElementById('flight-direction').addEventListener('input', function() {
                if (startMarker) {
                    updateDirectionArrow();
                }
            });
            
            // Update marker when coordinates change manually
            document.getElementById('start-latitude').addEventListener('change', function() {
                const lat = parseFloat(this.value);
                const lng = parseFloat(document.getElementById('start-longitude').value);
                if (!isNaN(lat) && !isNaN(lng)) {
                    setStartLocation(lat, lng);
                    if (map) {
                        map.setView([lat, lng], map.getZoom());
                    }
                }
            });
            
            document.getElementById('start-longitude').addEventListener('change', function() {
                const lat = parseFloat(document.getElementById('start-latitude').value);
                const lng = parseFloat(this.value);
                if (!isNaN(lat) && !isNaN(lng)) {
                    setStartLocation(lat, lng);
                    if (map) {
                        map.setView([lat, lng], map.getZoom());
                    }
                }
            });
        });

        // Add CSS for arrow icon
        const style = document.createElement('style');
        style.textContent = `
            .arrow-icon {
                background: none !important;
                border: none !important;
                color: #667eea;
                font-size: 16px;
                text-align: center;
                line-height: 20px;
                transform: rotate(var(--rotation, 0deg));
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>